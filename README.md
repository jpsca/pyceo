<h1>
<img alt="pyceo" src="https://raw.githubusercontent.com/jpsca/pyceo/master/pyceo.png">
</h1>

A minimal, composable, reusable, and ridiculously good looking command-line-**user**-interface toolkit.

- Made for interacting with humans
- No need to redeclare paramaters and options with decorators, just write Python methods.
- The help of a command is its docstring.
- Customizable main help page, but pretty by default.

## Usage

Declare a class that inherits from `pyceo.Cli`. Every method/attribute that does not starts with an underscore will be a command.

```python
from pyceo import Cli

class Manage(Cli):
    def first_command(self, arg1, arg2=3):
        pass

    def second_command(self):
        pass

    def _not_a_command(self):
        pass
```

Then, instance that class and call it.

```python
cli = Manage()

if __name__ == "__main__":
    cli()
```

You can add a `_intro` attribute to use as a message at the beginning of the help page.


### Subcommands

If an attribute is a subclass of `pyceo.Cli`, it will be a subcommand:

```python
from pyceo import Cli

class DBSub(Cli):
    def migrate(self):
        pass

class Manage(Cli):
    # A subcommand
    db = DBSub  # **NOT** `DBSub()`
```

### Context

You can pass any named argument as context to be used by your commands. This will be stored at the `_env` attribute.

Example:

```python
>>> cli = Manage(lorem="ipsum")
>>> print(cli._env)
{"lorem": "ipsum"}
```


## An example

![pyceo output](https://github.com/jpsca/pyceo/raw/master/output.png)

This autogenerated (and completely customizable) help message comes from running
the example below:

```python
# example.py
from pyceo import Cli


class DBCli(Cli):
    _intro = "Database-related commands"

    def migrate(self, **kwargs):
        """Autogenerate a new revision file.

        This is an alias for "revision --autogenerate".

        Arguments:
        - message: Revision message
        """
        pass


class MyCli(Cli):
    _intro = "This is PyCeo 3"

    def new(self, path, quiet=False):
        """Creates a new Proper application at `path`.

        The `proper new` command creates a new Proper application with a default
        directory structure and configuration at the path you specify.

        Example: `proper new ~/Code/blog`
        This generates a skeletal Proper application at `~/Code/blog`.

        Arguments:
        - path: Where to create the new application.
        - quiet [False]: Supress all output.
        """
        pass

    # A subcommand!
    db = DBCli


cli = MyCli()

if __name__ == "__main__":
    cli()

```


## Helpers

Apart of the CLI builder, pyceo includes some commonly-used helper functions

### confirm()

Ask a yes/no question via and return their answer.

### ask()

Ask a question via input() and return their answer.

### echo()

Renders a pyceo markup to the terminal.


## Markup system

pyceo uses a simple markup system for producing colored terminal text. Any text between a tag is printed with its style, and you can combine styles by using nested brightness, foreground, and background tags  (only one for each category).

### Brightness

- `<op:bright> ... </op>`
-  `<op:dim> ... </op>`

### Foreground color

- `<fg:black> ... </fg>`
- `<fg:red> ... </fg>`
- `<fg:green> ... </fg>`
- `<fg:yellow> ... </fg>`
- `<fg:blue> ... </fg>`
- `<fg:magenta> ... </fg>`
- `<fg:cyan> ... </fg>`
- `<fg:white> ... </fg>`
- `<fg:lblack> ... </fg>`
- `<fg:lred> ... </fg>`
- `<fg:lgreen> ... </fg>`
- `<fg:lyellow> ... </fg>`
- `<fg:lblue> ... </fg>`
- `<fg:lmagenta> ... </fg>`
- `<fg:lcyan> ... </fg>`
- `<fg:lwhite> ... </fg>`

### Background color

- `<bg:black> ... </bg>`
- `<bg:red> ... </bg>`
- `<bg:green> ... </bg>`
- `<bg:yellow> ... </bg>`
- `<bg:blue> ... </bg>`
- `<bg:magenta> ... </bg>`
- `<bg:cyan> ... </bg>`
- `<bg:white> ... </bg>`
- `<bg:lblack> ... </bg>`
- `<bg:lred> ... </bg>`
- `<bg:lgreen> ... </bg>`
- `<bg:lyellow> ... </bg>`
- `<bg:lblue> ... </bg>`
- `<bg:lmagenta> ... </bg>`
- `<bg:lcyan> ... </bg>`
- `<bg:lwhite> ... </bg>`


## FAQ

### Why don't just use optparse or argparse?

Are you kidding? Because this is way easier to use and understand.

### Why don't just use click?

Because this looks better and is easier to use and understand.

### Why don't just use...?

Because this library fits better my mental model. I hope it matches yours as well.
